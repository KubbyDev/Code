<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Gamedev Canvas Workshop</title>
    <style>
        * { padding: 0; margin: 0; }
        canvas { background: #7b7b7b; display: block; margin: 0 auto; }
    </style>
</head>
<body>

<canvas id="myCanvas" width="480" height="320"></canvas>

<script>

    const canvas = document.getElementById("myCanvas");
    const ctx = canvas.getContext("2d");

    class Ball {

        static color = "#3cd3ff";
        static radius = 5;
        static speedVal = 1;

        constructor(startAngle) {

            this.speed = [Math.cos(startAngle*Math.PI/180),Math.sin(startAngle*Math.PI/180)],
                this.position = [10,10]
        }

        move() {

            let delta = [0,0];
            delta[0] = this.speed[0] / Ball.speedVal;
            delta[1] = this.speed[1] / Ball.speedVal;
            let nbReps = Ball.speedVal;

            for(let i = 0; i < nbReps; i++) {

                //Collisions avec les briques
                for(let brick of bricks) {
                    //Collisions horizontales
                    if(this.position[0] + delta[0] > brick.position[0] - Brick.width/2 - Ball.radius
                        && this.position[0] + delta[0] < brick.position[0] + Brick.width/2 + Ball.radius
                        && this.position[1] > brick.position[1] - Brick.height/2 - Ball.radius
                        && this.position[1] < brick.position[1] + Brick.height/2 + Ball.radius) {
                        delta[0] *= -1;
                        this.speed[0] *= -1;
                        brick.hit();
                    }
                    //Collisions vertical
                    if(this.position[0] > brick.position[0] - Brick.width/2 - Ball.radius
                        && this.position[0] < brick.position[0] + Brick.width/2 + Ball.radius
                        && this.position[1] + delta[1] > brick.position[1] - Brick.height/2 - Ball.radius
                        && this.position[1] + delta[1] < brick.position[1] + Brick.height/2 + Ball.radius) {
                        delta[1] *= -1;
                        this.speed[1] *= -1;
                        brick.hit();
                    }
                }

                //Collisions avec les murs gauche ou droite
                if(this.position[0] + delta[0] - Ball.radius < 0 || this.position[0] + delta[0] + Ball.radius > canvas.width) {
                    delta[0] *= -1;
                    this.speed[0] *= -1;
                }
                //Collisions avec les murs haut et bas
                if(this.position[1] + delta[1] - Ball.radius < 0 || this.position[1] + delta[1] + Ball.radius > canvas.height) {
                    delta[1] *= -1;
                    this.speed[1] *= -1;
                }

                this.position[0] += delta[0];
                this.position[1] += delta[1];
            }
        }
    }

    class Brick {

        static color = "#b90003";
        static startHealth = 2;
        static width = 30;  //La largeur en partant du milieu
        static height = 30; //La hauteur en partant du milieu

        constructor(posX, posY) {
            this.health = Brick.startHealth,
                this.position = [posX, posY]
        }

        hit() {
            this.health -= 1;
            if(this.health <= 0)
                bricks.splice(bricks.indexOf(this), 1);
        }

    }

    function createBricks() {
        return [new Brick(40,50) ,new Brick(80,50),new Brick(120,50),new Brick(160,50), new Brick(200,50), new Brick(240,50), new Brick(280,50), new Brick(320,50)];
    }

    function update() {

        //Calcul des mouvements de chaque balle
        for(let ball of balls) {
            ball.move();
        }

        //Affichage de la frame
        draw();
    }

    function draw() {

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        for(let ball of balls) {

            //Affichage du disque
            ctx.beginPath();
            ctx.arc(Math.round(ball.position[0]), Math.round(ball.position[1]), Ball.radius, 0, Math.PI*2, false);
            ctx.fillStyle = Ball.color;
            ctx.fill();
            ctx.closePath();
        }

        for(let brick of bricks) {

            //Affichage du carre
            ctx.beginPath();
            ctx.rect(brick.position[0] - Brick.width/2, brick.position[1] - Brick.height/2, Brick.width, Brick.height);
            ctx.fillStyle = Brick.color;
            ctx.fill();
            ctx.closePath();

            //Affichage de la vie
            ctx.fillStyle = "#FFFFFF";
            ctx.textAlign = "center";
            ctx.textBaseline = "bottom";
            ctx.fillText(brick.health.toString(), brick.position[0]-1, brick.position[1]+5);
        }
    }

    let balls = [new Ball(30)];
    let bricks = createBricks();

    setInterval(update, 5);

</script>

</body>
</html>